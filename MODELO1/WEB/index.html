<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta name="facebook-domain-verification" content="hieiucxte7adq8gzeeeqvrnzlpulrn" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title id="dynamic-title">Carregando...</title>
  <meta name="robots" content="noindex, nofollow" />

  <!-- üöÄ PRELOADING RESOURCES FOR FASTER LOADING -->
  <!-- Preload critical CSS -->
  <link rel="preload" href="style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="style.css"></noscript>
  
  <!-- Preload main video -->
  <link rel="preload" href="assets/video.mp4" as="video" type="video/mp4">
  
  <!-- Preload hero image -->
  <link rel="preload" href="assets/imagem.jpg" as="image">
  
  <!-- Preload critical JavaScript files -->
  <link rel="preload" href="config.js" as="script">
  <link rel="preload" href="fb-pixel-manager.js" as="script">
  <link rel="preload" href="utmify-pixel-interceptor.js" as="script">
  <link rel="preload" href="invisible-tracking-capture.js" as="script">

  <!-- Font Awesome para √≠cones do header -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <!-- üé® LOADING SCREEN STYLES -->
  <style>
    /* Loading screen styles - embedded for instant display */
    .page-loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
    }

    .page-loader.fade-out {
      opacity: 0;
      visibility: hidden;
    }

    .loader-content {
      text-align: center;
      color: white;
    }

    .loader-logo {
      width: 80px;
      height: 80px;
      margin-bottom: 30px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      animation: pulse 2s infinite;
    }

    .loader-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    .loader-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .loader-subtext {
      font-size: 14px;
      opacity: 0.8;
      animation: fadeInOut 2s infinite;
    }

    .progress-bar {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      margin: 20px auto;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ffd93d);
      border-radius: 2px;
      width: 0%;
      animation: progressFill 3s ease-out forwards;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    @keyframes progressFill {
      0% { width: 0%; }
      20% { width: 30%; }
      50% { width: 60%; }
      80% { width: 85%; }
      100% { width: 100%; }
    }

    /* Hide main content until loaded */
    body:not(.loaded) .overlay {
      opacity: 0;
    }

    .overlay {
      transition: opacity 0.5s ease-in;
    }
  </style>

  <!-- üö® SCRIPT DE CAPTURA DE UTMs - DEVE SEMPRE PERMANECER NO TOPO DO HEAD -->
  <!-- Executa imediatamente para capturar UTMs antes de qualquer script async/defer -->
  <script>
    (function() {
      'use strict';
      
      // Configura√ß√£o
      const UTM_KEYS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term'];
      const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname.includes('dev');
      
      // Logging centralizado
      function log(message, data = null) {
        if (DEBUG_MODE) {
          console.log(`[UTM-TRACKING] ${message}`, data || '');
        }
      }
      
      // Fun√ß√£o para decodificar valor UTM
      function decodeUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        try {
          const decoded = decodeURIComponent(value);
          log(`Decodificado: "${value}" ‚Üí "${decoded}"`);
          return decoded;
        } catch (error) {
          log(`Erro ao decodificar "${value}":`, error);
          return value; // Retorna original se falhar
        }
      }
      
      // Fun√ß√£o para validar e separar formato nome|id
      function parseUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        const parts = value.split('|');
        if (parts.length === 2) {
          const [name, id] = parts;
          const isValid = name && id && /^\d+$/.test(id.trim());
          
          log(`Parse UTM: "${value}" ‚Üí nome: "${name}", id: "${id}", v√°lido: ${isValid}`);
          
          return {
            original: value,
            name: name.trim(),
            id: id.trim(),
            isValid: isValid
          };
        } else {
          log(`UTM sem formato nome|id: "${value}"`);
          return {
            original: value,
            name: value,
            id: null,
            isValid: false
          };
        }
      }
      
      // Fun√ß√£o para capturar UTMs da URL atual
      function captureUTMsFromURL() {
        const url = window.location.href;
        const searchParams = window.location.search;
        
        log('URL Original:', url);
        log('Query Params Bruto:', searchParams);
        
        if (!searchParams) {
          log('Nenhum par√¢metro UTM encontrado na URL');
          return {};
        }
        
        const params = new URLSearchParams(searchParams);
        const capturedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const rawValue = params.get(key);
          if (rawValue !== null) {
            const decodedValue = decodeUTMValue(rawValue);
            const parsed = parseUTMValue(decodedValue);
            
            capturedUTMs[key] = {
              raw: rawValue,
              decoded: decodedValue,
              parsed: parsed
            };
            
            log(`UTM ${key}:`, capturedUTMs[key]);
          }
        });
        
        return capturedUTMs;
      }
      
      // Fun√ß√£o para obter UTMs salvos do localStorage
      function getSavedUTMs() {
        const savedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const saved = localStorage.getItem(key);
          if (saved) {
            const parsed = parseUTMValue(saved);
            savedUTMs[key] = {
              saved: saved,
              parsed: parsed
            };
            log(`UTM salvo ${key}:`, savedUTMs[key]);
          }
        });
        
        return savedUTMs;
      }
      
      // Fun√ß√£o para salvar UTMs no localStorage
      function saveUTMs(utms) {
        Object.keys(utms).forEach(key => {
          const utmData = utms[key];
          if (utmData && utmData.decoded) {
            localStorage.setItem(key, utmData.decoded);
            log(`Salvo no localStorage: ${key} = "${utmData.decoded}"`);
          }
        });
      }
      
      // Fun√ß√£o para preservar UTMs em redirecionamentos
      function preserveUTMsInRedirect(newUrl) {
        const currentSearch = window.location.search;
        if (!currentSearch) return newUrl;
        
        const urlObj = new URL(newUrl, window.location.origin);
        const currentParams = new URLSearchParams(currentSearch);
        
        // Adicionar UTMs atuais se n√£o existirem na nova URL
        UTM_KEYS.forEach(key => {
          const currentValue = currentParams.get(key);
          if (currentValue && !urlObj.searchParams.has(key)) {
            urlObj.searchParams.set(key, currentValue);
            log(`Preservando UTM ${key} em redirecionamento: "${currentValue}"`);
          }
        });
        
        const finalUrl = urlObj.toString();
        log('URL com UTMs preservados:', finalUrl);
        return finalUrl;
      }
      
      // Fun√ß√£o principal de captura
      function captureAndProcessUTMs() {
        log('=== INICIANDO CAPTURA DE UTMs ===');
        
        // 1. Capturar UTMs da URL atual
        const urlUTMs = captureUTMsFromURL();
        
        // 2. Obter UTMs salvos do localStorage
        const savedUTMs = getSavedUTMs();
        
        // 3. Processar e salvar UTMs v√°lidos
        const validUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const urlUTM = urlUTMs[key];
          const savedUTM = savedUTMs[key];
          
          if (urlUTM && urlUTM.parsed && urlUTM.parsed.isValid) {
            // Priorizar UTMs da URL se v√°lidos
            validUTMs[key] = urlUTM.decoded;
            log(`Usando UTM da URL: ${key} = "${urlUTM.decoded}"`);
          } else if (savedUTM && savedUTM.parsed && savedUTM.parsed.isValid) {
            // Fallback para UTMs salvos se v√°lidos
            validUTMs[key] = savedUTM.saved;
            log(`Usando UTM salvo: ${key} = "${savedUTM.saved}"`);
          } else if (urlUTM && urlUTM.decoded) {
            // Salvar mesmo se n√£o tiver formato nome|id
            validUTMs[key] = urlUTM.decoded;
            log(`Salvando UTM sem formato nome|id: ${key} = "${urlUTM.decoded}"`);
          }
        });
        
        // 4. Salvar no localStorage
        saveUTMs(urlUTMs);
        
        log('=== UTMs CAPTURADOS ===', validUTMs);
        return validUTMs;
      }
      
      // Interceptar redirecionamentos para preservar UTMs
      function setupRedirectPreservation() {
        // Sobrescrever window.location.href
        const originalLocationHref = Object.getOwnPropertyDescriptor(window.location, 'href');
        
        Object.defineProperty(window.location, 'href', {
          set: function(url) {
            const preservedUrl = preserveUTMsInRedirect(url);
            originalLocationHref.set.call(this, preservedUrl);
          },
          get: originalLocationHref.get,
          configurable: true
        });
        
        // Sobrescrever window.location.replace
        const originalReplace = window.location.replace;
        window.location.replace = function(url) {
          const preservedUrl = preserveUTMsInRedirect(url);
          return originalReplace.call(this, preservedUrl);
        };
        
        // Sobrescrever window.location.assign
        const originalAssign = window.location.assign;
        window.location.assign = function(url) {
          const preservedUrl = preserveUTMsInRedirect(url);
          return originalAssign.call(this, preservedUrl);
        };
        
        log('Intercepta√ß√£o de redirecionamentos configurada');
      }
      
      // Fun√ß√£o para obter UTMs processados
      function getProcessedUTMs() {
        const utms = {};
        UTM_KEYS.forEach(key => {
          const value = localStorage.getItem(key);
          if (value) {
            utms[key] = value;
          }
        });
        return utms;
      }
      
      // Executar captura imediatamente
      const capturedUTMs = captureAndProcessUTMs();
      
      // Configurar preserva√ß√£o de redirecionamentos
      setupRedirectPreservation();
      
      // Expor fun√ß√µes globalmente
      window.UTMTracking = {
        capture: captureAndProcessUTMs,
        get: getProcessedUTMs,
        preserve: preserveUTMsInRedirect,
        log: log
      };
      
      // Executar novamente quando DOM estiver pronto (fallback)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          log('Re-executando captura ap√≥s DOMContentLoaded');
          captureAndProcessUTMs();
        });
      }
      
      log('Script UTM Tracking carregado e executado');
    })();
  </script>

  <!-- üéØ INTERCEPTADOR DO PIXEL DA UTMIFY - DEVE VIR ANTES DO PIXEL -->
  <!-- Este script intercepta e registra todas as requisi√ß√µes do Pixel da UTMify -->
  <script src="utmify-pixel-interceptor.js"></script>

  <!-- üî• NOVO SISTEMA DE GERENCIAMENTO DO FACEBOOK PIXEL -->
  <!-- Sistema robusto que carrega configura√ß√µes dinamicamente do .env -->
  <script src="fb-pixel-manager.js"></script>
  
  <!-- üîê SISTEMA DE TRACKING INVIS√çVEL -->
  <!-- Captura dados de entrada e gera token JWT seguro para checkout -->
  <script src="invisible-tracking-capture.js"></script>
  
  <!-- üîó META PIXEL BRIDGE -->
  <!-- Bridge para compatibilidade com Meta Pixel Helper -->
  <script src="meta-pixel-bridge.js"></script>
  
  <!-- Script de compatibilidade para manter fun√ß√µes legadas -->
  <script>
    // Manter compatibilidade com c√≥digo existente
    window.fbConfig = { FB_PIXEL_ID: '', FB_TEST_EVENT_CODE: 'TEST74140', loaded: false };
    
    // Fun√ß√£o legada para compatibilidade
    function addTestEventCode(eventData = {}) {
      if (window.FBPixelManager && window.FBPixelManager.addTestEventCode) {
        return window.FBPixelManager.addTestEventCode(eventData);
      }
      return eventData;
    }
    
    // Aguardar inicializa√ß√£o do FBPixelManager
    function waitForPixelManager(callback, maxAttempts = 50) {
      let attempts = 0;
      
      const checkReady = () => {
        attempts++;
        
        if (window.FBPixelManager && window.FBPixelManager.isReady()) {
          // Sincronizar configura√ß√£o legada
          const config = window.FBPixelManager.getConfig();
          window.fbConfig = {
            FB_PIXEL_ID: config.FB_PIXEL_ID,
            FB_TEST_EVENT_CODE: config.FB_TEST_EVENT_CODE,
            loaded: true
          };
          
          callback();
        } else if (attempts < maxAttempts) {
          setTimeout(checkReady, 100);
        } else {
          console.warn('‚ö†Ô∏è Timeout aguardando inicializa√ß√£o do Facebook Pixel Manager');
          callback(); // Executar callback mesmo assim
        }
      };
      
      checkReady();
    }
    
    // Aguardar pixel manager estar pronto e disparar ViewContent inicial
    waitForPixelManager(() => {
      if (window.FBPixelManager && window.FBPixelManager.isReady()) {
        // Disparar ViewContent inicial ap√≥s inicializa√ß√£o
        const viewContentData = {
          value: parseFloat((Math.random() * (19.90 - 9.90) + 9.90).toFixed(2)),
          currency: 'BRL'
        };
        
        window.FBPixelManager.track('ViewContent', viewContentData)
          .then(result => {
            console.log('‚úÖ ViewContent inicial disparado:', result);
          })
          .catch(error => {
            console.error('‚ùå Erro ao disparar ViewContent inicial:', error);
          });
      }
    });
  </script>

  <link rel="stylesheet" href="style.css" />
  <script src="config.js"></script>
  <!-- üö® REMOVIDO: utm-capture.js - substitu√≠do pelo script inline acima -->
  <script src="fbclid-handler.js"></script>
  <script src="event-id.js"></script>
  <script src="utmify-back-redirect.js"></script>
  <script src="event-tracking-initiate.js"></script>
  
  <!-- üé¨ SISTEMA ROBUSTO DE CARREGAMENTO DE M√çDIAS -->
  <script src="robust-media-loader.js"></script>
  
  <!-- üéØ SISTEMA DE TRACKING DO KWAI EVENT API -->
  <script src="kwai-click-tracker.js"></script>
  
  <!-- Estilos para status online e localiza√ß√£o -->
  <style>
    .status-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin: 15px 0;
      color: rgba(255, 255, 255, 0.9);
      font-weight: 600;
      font-size: 15px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .online-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .online-dot {
      width: 8px;
      height: 8px;
      background: #4CAF50;
      border-radius: 50%;
      box-shadow: 0 0 6px #4CAF50;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.4;
        transform: scale(0.8);
      }
    }
    
    .status-separator {
      font-size: 14px;
      opacity: 0.7;
      margin: 0 2px;
    }
    
    .location-info {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .location-icon {
      width: 14px;
      height: 14px;
      opacity: 0.8;
    }
    
    #user-city {
      font-weight: 600;
    }
  </style>
  <script
    src="https://cdn.utmify.com.br/scripts/utms/latest.js"
    data-utmify-prevent-xcod-sck
    data-utmify-prevent-subids
    async
    defer
  ></script>
</head>
<body>
  <!-- üé¨ LOADING SCREEN -->
  <div id="page-loader" class="page-loader">
    <div class="loader-content">
      <div class="loader-logo">üî•</div>
      <div class="loader-spinner"></div>
      <div class="loader-text">Carregando experi√™ncia exclusiva...</div>
      <div class="progress-bar">
        <div class="progress-fill"></div>
      </div>
      <div class="loader-subtext">Preparando conte√∫do premium</div>
    </div>
  </div>

  <!-- Header fixo -->
  <header id="main-header" class="fixed-header">
    <div class="header-container">
      <div class="header-left">
        <div class="back-button" id="back-button" onclick="window.history.back()">
          <i class="fas fa-chevron-left"></i>
        </div>
      </div>
      
      <div class="header-center">
        <a href="/" class="header-logo">
          <img src="assets/logo.png" alt="Logo" onerror="this.style.display='none'">
          <span class="logo-text">Privacy</span>
        </a>
      </div>
      
      <div class="header-right">
        <div class="header-menu" onclick="toggleMenu()">
          <i class="fas fa-bars"></i>
        </div>
      </div>
    </div>
  </header>

  <!-- V√≠deo de fundo -->
  <video id="background-video" autoplay muted loop playsinline>
    <source src="assets/video.mp4" type="video/mp4">
  </video>
  
  <div class="overlay">
    <!-- Headline acima da foto -->
    <h1 id="headline">üî• Oferta limitada üî•</h1>
    
    <!-- Imagem central com efeito oval e glow -->
    <img id="profile-image" src="assets/imagem.jpg" alt="Perfil" />
    
    <!-- Status online e localiza√ß√£o -->
    <div class="status-container">
      <div class="online-indicator">
        <div class="online-dot"></div>
        <span>ONLINE AGORA</span>
      </div>
      <span class="status-separator">‚Ä¢</span>
      <div class="location-info">
        <svg class="location-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
          <path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 9.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5z"/>
        </svg>
        <span id="user-city"></span>
      </div>
    </div>
    
    <div id="message">
      <p>A melhor bunda que voc√™ vai ver hoje, com os peitos perfeitos üçë</p>
    </div>
    
    <!-- Novos bot√µes pill -->
    <div class="button-container">
      <a id="telegram-btn" class="btn-pill btn-telegram" href="#" aria-label="Acessar Telegram">
        <div class="btn-icon-chip">
          <img src="assets/icon-2.png" alt="√çcone Telegram" class="btn-icon" onerror="this.style.display='none'">
        </div>
        <span>Telegram</span>
      </a>
      <a id="privacy-btn" class="btn-pill btn-privacy" href="/privacy" aria-label="Acessar Privacy">
        <div class="btn-icon-chip">
          <img src="assets/icon-3.png" alt="√çcone Privacy" class="btn-icon" onerror="this.style.display='none'">
        </div>
        <span>Privacy</span>
      </a>
    </div>
  </div>

  <script>
  // Aplica conte√∫do da config
  document.title = window.config.title;
  // texto fixo definido no HTML

  const telegramBtn = document.getElementById("telegram-btn");
  const privacyBtn = document.getElementById("privacy-btn");
  let welcomeEventFired = false;

  // Base do bot
  const baseUrl = window.config.redirectLink;
  const trackData = {};

  function trackWelcomeEvent() {
    if (!welcomeEventFired) {
      welcomeEventFired = true;
      fetch('/api/track-welcome', { method: 'POST' })
        .then(() => console.log('‚úÖ Welcome event fired from index.html'))
        .catch(err => console.error('Erro ao rastrear evento welcome:', err));
    }
  }

  // Usar PIXEL_ID das configura√ß√µes carregadas
  function getPixelId() {
    if (window.FBPixelManager && window.FBPixelManager.getConfig) {
      const config = window.FBPixelManager.getConfig();
      return config.FB_PIXEL_ID || '';
    }
    return window.fbConfig && window.fbConfig.FB_PIXEL_ID ? window.fbConfig.FB_PIXEL_ID : '';
  }

  function getCookie(name) {
    const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
    return match ? decodeURIComponent(match[1]) : null;
  }

  function getPixelValue(lsKey, cookieName) {
    const defaultValue = lsKey === 'fbp' ? 'nofbp' : 'nofbc';
    return new Promise(resolve => {
      try {
        const stored = localStorage.getItem(lsKey);
        if (stored) return resolve(stored);

        const cookieVal = getCookie(cookieName);
        if (cookieVal) {
          localStorage.setItem(lsKey, cookieVal);
          return resolve(cookieVal);
        }
      } catch (e) {
        console.error('Erro ao acessar storage/cookie', e);
      }

      resolve(defaultValue);
    });
  }

  async function gatherTracking() {
    const fresh = {};

    const [fbp, fbc] = await Promise.all([
      getPixelValue('fbp', '_fbp'),
      getPixelValue('fbc', '_fbc')
    ]);

    let ip = localStorage.getItem('client_ip_address');
    if (!ip) {
      try {
        const fetchIp = fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => d.ip);
        ip = await Promise.race([
          fetchIp,
          new Promise(res => setTimeout(() => res(null), 2000))
        ]);
        if (ip) localStorage.setItem('client_ip_address', ip);
      } catch (e) {}
    }

    let ua = localStorage.getItem('user_agent_criacao');
    if (!ua) {
      try {
        ua = navigator.userAgent;
        localStorage.setItem('user_agent_criacao', ua);
      } catch (e) {}
    }

    const urlParams = new URLSearchParams(window.location.search);
    ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'].forEach(key => {
      const value = urlParams.get(key) || localStorage.getItem(key);
      if (value) {
        fresh[key] = value;
        localStorage.setItem(key, value);
      }
    });

    if (fbp) fresh.fbp = fbp;
    if (fbc) fresh.fbc = fbc;
    if (ip) fresh.ip = ip;
    if (ua) fresh.user_agent = ua;

    Object.assign(trackData, fresh);
    console.log('[DEBUG] trackData:', trackData);
    return fresh;
  }


  async function gerarPayload() {
    // Captura cookies do Facebook mais recentes antes de gerar payload
    await gatherTracking();
    
    // Garantir que temos os cookies mais recentes usando a fun√ß√£o do utm-capture.js
    if (window.getFacebookCookies) {
      const freshCookies = window.getFacebookCookies();
      if (freshCookies.fbp) trackData.fbp = freshCookies.fbp;
      if (freshCookies.fbc) trackData.fbc = freshCookies.fbc;
    }
    
    try {
      const { fbp, fbc, ip, user_agent, utm_source, utm_medium, utm_campaign, utm_term, utm_content } = trackData;
      
      // üéØ KWAI TRACKING: Incluir click_id no payload
      let kwai_click_id = null;
      if (window.KwaiTracker && window.KwaiTracker.getClickId) {
        kwai_click_id = window.KwaiTracker.getClickId();
      }
      
      const resp = await fetch('/api/gerar-payload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          fbp,
          fbc,
          ip,
          user_agent,
          utm_source,
          utm_medium,
          utm_campaign,
          utm_term,
          utm_content,
          kwai_click_id
        })
      });

      const data = await resp.json().catch(() => ({}));
      if (resp.ok && data.payload_id) {
        // üî• NOVO: Incluir kwai_click_id na URL do bot se dispon√≠vel
        const kwaiClickId = window.KwaiTracker ? window.KwaiTracker.getClickId() : null;
        const startParam = data.payload_id;
        const kwaiParam = kwaiClickId ? `&kwai_click_id=${encodeURIComponent(kwaiClickId)}` : '';
        telegramBtn.href = `${baseUrl}?start=${startParam}${kwaiParam}`;
        trackWelcomeEvent();
        console.log('üîó Payload gerado com cookies do Facebook:', { fbp: !!fbp, fbc: !!fbc, kwai_click_id: kwaiClickId ? kwaiClickId.substring(0, 10) + '...' : null });
      } else {
        // üî• NOVO: Incluir kwai_click_id na URL do bot mesmo sem payload
        const kwaiClickId = window.KwaiTracker ? window.KwaiTracker.getClickId() : null;
        const kwaiParam = kwaiClickId ? `?kwai_click_id=${encodeURIComponent(kwaiClickId)}` : '';
        telegramBtn.href = `${baseUrl}${kwaiParam}`;
        trackWelcomeEvent();
      }
    } catch (e) {
      console.error('Erro ao gerar payload', e);
      telegramBtn.href = baseUrl;
      trackWelcomeEvent();
    }
  }

  // Fun√ß√£o para detectar cidade do usu√°rio
  async function detectUserCity() {
    const cityElement = document.getElementById('user-city');
    const locationInfo = cityElement.closest('.location-info');
    const statusSeparator = document.querySelector('.status-separator');
    
    // Inicialmente esconder a se√ß√£o de localiza√ß√£o
    locationInfo.style.display = 'none';
    statusSeparator.style.display = 'none';
    
    const geoAPIs = [
      {
        url: 'https://ipinfo.io/json',
        parseCity: (data) => data.city
      },
      {
        url: 'https://ipapi.co/json/',
        parseCity: (data) => (!data.error && data.city) ? data.city : null
      },
      {
        url: 'https://geolocation-db.com/json/',
        parseCity: (data) => (data.city && data.city !== 'Not found') ? data.city : null
      }
    ];
    
    for (const api of geoAPIs) {
      try {
        const response = await fetch(api.url, {
          headers: { 'Accept': 'application/json' },
          timeout: 5000
        });
        
        if (!response.ok) continue;
        
        const data = await response.json();
        const city = api.parseCity(data);
        
        if (city && city.trim()) {
          cityElement.textContent = city;
          // Mostrar a se√ß√£o de localiza√ß√£o apenas quando detectar
          locationInfo.style.display = 'flex';
          statusSeparator.style.display = 'inline';
          console.log('üåç Cidade detectada:', city);
          return;
        }
      } catch (error) {
        console.log('Erro na API de geolocaliza√ß√£o:', error);
        continue;
      }
    }
    
    // Fallback - se nenhuma cidade for detectada, manter apenas "ONLINE AGORA"
    console.log('üåç Nenhuma cidade detectada, mantendo apenas status online');
    // Deixar se√ß√£o de localiza√ß√£o escondida (fallback conforme solicitado)
  }

  window.addEventListener('load', () => {
    telegramBtn.classList.add('disabled');
    telegramBtn.href = '#';

    setTimeout(async () => {
      await gerarPayload();
      telegramBtn.classList.remove('disabled');
      // Detectar cidade do usu√°rio ap√≥s um pequeno delay
      setTimeout(detectUserCity, 500);
    }, 500);
  });

  telegramBtn.addEventListener("click", function () {
    try {
      // üî• DISPARAR FLUXO DE EVENTOS ADD TO CART + INITIATE CHECKOUT
      console.log('üéØ CTA clicado - iniciando fluxo de eventos');

      // üéØ KWAI TRACKING: Enviar EVENT_CONTENT_VIEW
      if (window.KwaiTracker && window.KwaiTracker.hasValidClickId()) {
        window.KwaiTracker.sendContentView({
          content_name: window.config.headline || 'Landing Page Telegram',
          content_category: 'Bot Telegram',
          content_id: 'telegram_cta'
        }).then(result => {
          console.log('üéØ Kwai EVENT_CONTENT_VIEW enviado:', result);
        }).catch(err => {
          console.error('‚ùå Erro ao enviar Kwai EVENT_CONTENT_VIEW:', err);
        });
      }

      // Rastrear clique do CTA no backend
      fetch('/api/track-cta-click', { method: 'POST' })
        .catch(err => console.error('Erro ao rastrear clique do CTA:', err));

      // Disparar eventos de convers√£o
      const flowResult = window.EventTracking.triggerInitiateFlowEvents();
      
      // Disparar ViewContent adicional usando o novo sistema
      const viewContentData = {
        value: parseFloat((Math.random() * (19.90 - 9.90) + 9.90).toFixed(2)),
        currency: 'BRL',
        content_name: window.config.headline,
        content_category: 'Bot Telegram'
      };
      
      if (window.FBPixelManager && window.FBPixelManager.isReady()) {
        window.FBPixelManager.track('ViewContent', viewContentData)
          .then(result => {
            console.log('‚úÖ ViewContent CTA disparado:', result);
          })
          .catch(error => {
            console.error('‚ùå Erro ao disparar ViewContent CTA:', error);
            // Fallback para m√©todo tradicional
            if (window.fbq) {
              const legacyData = addTestEventCode({...viewContentData, eventID: generateEventID('ViewContent')});
              fbq('track', 'ViewContent', legacyData);
            }
          });
      } else {
        // Fallback para m√©todo tradicional se o manager n√£o estiver pronto
        if (window.fbq) {
          const legacyData = addTestEventCode({...viewContentData, eventID: generateEventID('ViewContent')});
          fbq('track', 'ViewContent', legacyData);
        }
      }
      
      console.log('‚úÖ Fluxo de eventos conclu√≠do - redirecionando para Telegram');
      
    } catch (e) {
      console.error('‚ùå Erro no fluxo de eventos:', e);
    }
  });

  // üî• NOVO: Event listener para o bot√£o Privacy
  privacyBtn.addEventListener("click", function (e) {
    e.preventDefault();
    
    try {
      console.log('üéØ CTA Privacy clicado - redirecionando com click_id');
      
      // Capturar click_id da URL atual
      const urlParams = new URLSearchParams(window.location.search);
      const clickId = urlParams.get('click_id') || urlParams.get('kwai_click_id');
      
      // Construir URL do Privacy com click_id
      let privacyUrl = '/privacy';
      if (clickId) {
        privacyUrl += `?click_id=${encodeURIComponent(clickId)}`;
        
        // Adicionar outros par√¢metros de tracking se dispon√≠veis
        const utmParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'];
        utmParams.forEach(param => {
          const value = urlParams.get(param);
          if (value) {
            privacyUrl += `&${param}=${encodeURIComponent(value)}`;
          }
        });
        
        // Adicionar fbp/fbc se dispon√≠veis
        const fbp = localStorage.getItem('fbp');
        const fbc = localStorage.getItem('fbc');
        if (fbp) privacyUrl += `&fbp=${encodeURIComponent(fbp)}`;
        if (fbc) privacyUrl += `&fbc=${encodeURIComponent(fbc)}`;
        
        console.log('üîó URL do Privacy constru√≠da:', privacyUrl);
      } else {
        console.log('‚ö†Ô∏è Nenhum click_id encontrado, redirecionando sem tracking');
      }
      
      // üéØ KWAI TRACKING: Enviar EVENT_CONTENT_VIEW antes do redirecionamento
      if (window.KwaiTracker && window.KwaiTracker.hasValidClickId()) {
        window.KwaiTracker.sendContentView({
          content_name: window.config.headline || 'Landing Page Privacy',
          content_category: 'Bot Privacy',
          content_id: 'privacy_cta'
        }).then(result => {
          console.log('üéØ Kwai EVENT_CONTENT_VIEW enviado para Privacy:', result);
        }).catch(err => {
          console.error('‚ùå Erro ao enviar Kwai EVENT_CONTENT_VIEW para Privacy:', err);
        });
      }
      
      // Redirecionar para o Privacy
      window.location.href = privacyUrl;
      
    } catch (error) {
      console.error('‚ùå Erro ao redirecionar para Privacy:', error);
      // Fallback: redirecionar sem par√¢metros
      window.location.href = '/privacy';
    }
  });

  // Aplica√ß√£o de fundo removida - agora usando v√≠deo de fundo
  
  // ===== FUNCIONALIDADE DO HEADER =====
  function toggleMenu() {
    // Implementar funcionalidade do menu se necess√°rio
    console.log('Menu clicado');
    // Aqui voc√™ pode adicionar um dropdown menu, sidebar, etc.
  }
  
  // Efeito de scroll no header (opcional)
  let lastScrollTop = 0;
  const header = document.getElementById('main-header');
  
  window.addEventListener('scroll', function() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    if (scrollTop > lastScrollTop && scrollTop > 100) {
      // Scrolling down - hide header
      header.style.transform = 'translateY(-100%)';
    } else {
      // Scrolling up - show header
      header.style.transform = 'translateY(0)';
    }
    
    lastScrollTop = scrollTop;
  });
  
  </script>

  <!-- üöÄ LOADING SYSTEM SCRIPT -->
  <script>
    (function() {
      'use strict';
      
      let resourcesLoaded = 0;
      let totalResources = 0;
      let loadingComplete = false;
      
      const loader = document.getElementById('page-loader');
      const progressFill = document.querySelector('.progress-fill');
      const loaderText = document.querySelector('.loader-text');
      const loaderSubtext = document.querySelector('.loader-subtext');
      
      // Loading messages
      const loadingMessages = [
        'Carregando experi√™ncia exclusiva...',
        'Preparando conte√∫do premium...',
        'Otimizando performance...',
        'Quase pronto...'
      ];
      
      const subtextMessages = [
        'Preparando conte√∫do premium',
        'Carregando recursos essenciais',
        'Configurando experi√™ncia',
        'Finalizando carregamento'
      ];
      
      let messageIndex = 0;
      
      // Update loading message periodically
      const messageInterval = setInterval(() => {
        if (loadingComplete) {
          clearInterval(messageInterval);
          return;
        }
        
        messageIndex = (messageIndex + 1) % loadingMessages.length;
        loaderText.textContent = loadingMessages[messageIndex];
        loaderSubtext.textContent = subtextMessages[messageIndex];
      }, 800);
      
      // Count resources to load
      function countResources() {
        const images = document.querySelectorAll('img');
        const videos = document.querySelectorAll('video');
        const scripts = document.querySelectorAll('script[src]');
        const stylesheets = document.querySelectorAll('link[rel="stylesheet"], link[rel="preload"][as="style"]');
        
        totalResources = images.length + videos.length + scripts.length + stylesheets.length;
        console.log(`üîÑ Total resources to load: ${totalResources}`);
      }
      
      // Update progress
      function updateProgress() {
        if (totalResources === 0) return;
        
        const progress = Math.min((resourcesLoaded / totalResources) * 100, 100);
        
        // Update progress bar (animation is already handled by CSS)
        console.log(`üìä Loading progress: ${progress.toFixed(1)}%`);
        
        if (progress >= 100 || resourcesLoaded >= totalResources) {
          finishLoading();
        }
      }
      
      // Resource loaded callback
      function resourceLoaded() {
        resourcesLoaded++;
        updateProgress();
      }
      
      // Setup resource monitoring
      function setupResourceMonitoring() {
        // Monitor images
        document.querySelectorAll('img').forEach(img => {
          if (img.complete) {
            resourceLoaded();
          } else {
            img.addEventListener('load', resourceLoaded);
            img.addEventListener('error', resourceLoaded);
          }
        });
        
        // Monitor videos
        document.querySelectorAll('video').forEach(video => {
          if (video.readyState >= 2) {
            resourceLoaded();
          } else {
            video.addEventListener('loadeddata', resourceLoaded);
            video.addEventListener('error', resourceLoaded);
          }
        });
        
        // Scripts and stylesheets are harder to monitor, so we'll use a timer approach
        const scriptsAndStyles = document.querySelectorAll('script[src], link[rel="stylesheet"], link[rel="preload"][as="style"]');
        scriptsAndStyles.forEach((element, index) => {
          // Simulate loading with a slight delay
          setTimeout(() => {
            resourceLoaded();
          }, index * 50 + Math.random() * 200);
        });
      }
      
      // Finish loading
      function finishLoading() {
        if (loadingComplete) return;
        
        loadingComplete = true;
        clearInterval(messageInterval);
        
        console.log('‚úÖ All resources loaded, hiding loader');
        
        // Update final message
        loaderText.textContent = 'Pronto!';
        loaderSubtext.textContent = 'Bem-vindo √† experi√™ncia premium';
        
        // Add loaded class to body
        document.body.classList.add('loaded');
        
        // Hide loader after a short delay
        setTimeout(() => {
          loader.classList.add('fade-out');
          
          // Remove loader from DOM after transition
          setTimeout(() => {
            if (loader && loader.parentNode) {
              loader.parentNode.removeChild(loader);
            }
          }, 500);
        }, 300);
      }
      
      // Initialize loading system
      function initLoadingSystem() {
        console.log('üöÄ Initializing loading system');
        
        countResources();
        
        if (totalResources === 0) {
          // No resources to load, finish immediately
          setTimeout(finishLoading, 1000);
          return;
        }
        
        setupResourceMonitoring();
        
        // Fallback: always finish loading after maximum time
        setTimeout(() => {
          if (!loadingComplete) {
            console.log('‚è∞ Loading timeout reached, forcing completion');
            finishLoading();
          }
        }, 5000);
        
        // Minimum loading time for better UX
        setTimeout(() => {
          if (resourcesLoaded >= totalResources * 0.8) {
            finishLoading();
          }
        }, 1500);
      }
      
      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initLoadingSystem);
      } else {
        initLoadingSystem();
      }
      
      // Also trigger on window load as fallback
      window.addEventListener('load', () => {
        setTimeout(() => {
          if (!loadingComplete) {
            console.log('ü™ü Window loaded, forcing completion');
            finishLoading();
          }
        }, 500);
      });
    })();
  </script>
</body></html>
