<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta name="facebook-domain-verification" content="62pz7fns7akzu7khx80kk0uth0fq99" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title id="dynamic-title">Carregando...</title>
  <meta name="robots" content="noindex, nofollow" />

  <!-- üö® SCRIPT DE CAPTURA DE UTMs - DEVE SEMPRE PERMANECER NO TOPO DO HEAD -->
  <!-- Executa imediatamente para capturar UTMs antes de qualquer script async/defer -->
  <script>
    (function() {
      'use strict';
      
      // Configura√ß√£o
      const UTM_KEYS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term'];
      const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname.includes('dev');
      
      // Logging centralizado
      function log(message, data = null) {
        if (DEBUG_MODE) {
          console.log(`[UTM-TRACKING] ${message}`, data || '');
        }
      }
      
      // Fun√ß√£o para decodificar valor UTM
      function decodeUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        try {
          const decoded = decodeURIComponent(value);
          log(`Decodificado: "${value}" ‚Üí "${decoded}"`);
          return decoded;
        } catch (error) {
          log(`Erro ao decodificar "${value}":`, error);
          return value; // Retorna original se falhar
        }
      }
      
      // Fun√ß√£o para validar e separar formato nome|id
      function parseUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        const parts = value.split('|');
        if (parts.length === 2) {
          const [name, id] = parts;
          const isValid = name && id && /^\d+$/.test(id.trim());
          
          log(`Parse UTM: "${value}" ‚Üí nome: "${name}", id: "${id}", v√°lido: ${isValid}`);
          
          return {
            original: value,
            name: name.trim(),
            id: id.trim(),
            isValid: isValid
          };
        } else {
          log(`UTM sem formato nome|id: "${value}"`);
          return {
            original: value,
            name: value,
            id: null,
            isValid: false
          };
        }
      }
      
      // Fun√ß√£o para capturar UTMs da URL atual
      function captureUTMsFromURL() {
        const url = window.location.href;
        const searchParams = window.location.search;
        
        log('URL Original:', url);
        log('Query Params Bruto:', searchParams);
        
        if (!searchParams) {
          log('Nenhum par√¢metro UTM encontrado na URL');
          return {};
        }
        
        const params = new URLSearchParams(searchParams);
        const capturedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const rawValue = params.get(key);
          if (rawValue !== null) {
            const decodedValue = decodeUTMValue(rawValue);
            const parsed = parseUTMValue(decodedValue);
            
            capturedUTMs[key] = {
              raw: rawValue,
              decoded: decodedValue,
              parsed: parsed
            };
            
            log(`UTM ${key}:`, capturedUTMs[key]);
          }
        });
        
        return capturedUTMs;
      }
      
      // Fun√ß√£o para obter UTMs salvos do localStorage
      function getSavedUTMs() {
        const savedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const saved = localStorage.getItem(key);
          if (saved) {
            const parsed = parseUTMValue(saved);
            savedUTMs[key] = {
              saved: saved,
              parsed: parsed
            };
            log(`UTM salvo ${key}:`, savedUTMs[key]);
          }
        });
        
        return savedUTMs;
      }
      
      // Fun√ß√£o para salvar UTMs no localStorage
      function saveUTMs(utms) {
        Object.keys(utms).forEach(key => {
          const utmData = utms[key];
          if (utmData && utmData.decoded) {
            localStorage.setItem(key, utmData.decoded);
            log(`Salvo no localStorage: ${key} = "${utmData.decoded}"`);
          }
        });
      }
      
      // Fun√ß√£o para preservar UTMs em redirecionamentos
      function preserveUTMsInRedirect(newUrl) {
        const currentSearch = window.location.search;
        if (!currentSearch) return newUrl;
        
        const urlObj = new URL(newUrl, window.location.origin);
        const currentParams = new URLSearchParams(currentSearch);
        
        // Adicionar UTMs atuais se n√£o existirem na nova URL
        UTM_KEYS.forEach(key => {
          const currentValue = currentParams.get(key);
          if (currentValue && !urlObj.searchParams.has(key)) {
            urlObj.searchParams.set(key, currentValue);
            log(`Preservando UTM ${key} em redirecionamento: "${currentValue}"`);
          }
        });
        
        const finalUrl = urlObj.toString();
        log('URL com UTMs preservados:', finalUrl);
        return finalUrl;
      }
      
      // Fun√ß√£o principal de captura
      function captureAndProcessUTMs() {
        log('=== INICIANDO CAPTURA DE UTMs ===');
        
        // 1. Capturar UTMs da URL atual
        const urlUTMs = captureUTMsFromURL();
        
        // 2. Obter UTMs salvos do localStorage
        const savedUTMs = getSavedUTMs();
        
        // 3. Processar e salvar UTMs v√°lidos
        const validUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const urlUTM = urlUTMs[key];
          const savedUTM = savedUTMs[key];
          
          if (urlUTM && urlUTM.parsed && urlUTM.parsed.isValid) {
            // Priorizar UTMs da URL se v√°lidos
            validUTMs[key] = urlUTM.decoded;
            log(`Usando UTM da URL: ${key} = "${urlUTM.decoded}"`);
          } else if (savedUTM && savedUTM.parsed && savedUTM.parsed.isValid) {
            // Fallback para UTMs salvos se v√°lidos
            validUTMs[key] = savedUTM.saved;
            log(`Usando UTM salvo: ${key} = "${savedUTM.saved}"`);
          } else if (urlUTM && urlUTM.decoded) {
            // Salvar mesmo se n√£o tiver formato nome|id
            validUTMs[key] = urlUTM.decoded;
            log(`Salvando UTM sem formato nome|id: ${key} = "${urlUTM.decoded}"`);
          }
        });
        
        // 4. Salvar no localStorage
        saveUTMs(urlUTMs);
        
        log('=== UTMs CAPTURADOS ===', validUTMs);
        return validUTMs;
      }
      
      // Interceptar redirecionamentos para preservar UTMs
      function setupRedirectPreservation() {
        // Sobrescrever window.location.href
        const originalLocationHref = Object.getOwnPropertyDescriptor(window.location, 'href');
        
        Object.defineProperty(window.location, 'href', {
          set: function(url) {
            const preservedUrl = preserveUTMsInRedirect(url);
            originalLocationHref.set.call(this, preservedUrl);
          },
          get: originalLocationHref.get,
          configurable: true
        });
        
        // Sobrescrever window.location.replace
        const originalReplace = window.location.replace;
        window.location.replace = function(url) {
          const preservedUrl = preserveUTMsInRedirect(url);
          return originalReplace.call(this, preservedUrl);
        };
        
        // Sobrescrever window.location.assign
        const originalAssign = window.location.assign;
        window.location.assign = function(url) {
          const preservedUrl = preserveUTMsInRedirect(url);
          return originalAssign.call(this, preservedUrl);
        };
        
        log('Intercepta√ß√£o de redirecionamentos configurada');
      }
      
      // Fun√ß√£o para obter UTMs processados
      function getProcessedUTMs() {
        const utms = {};
        UTM_KEYS.forEach(key => {
          const value = localStorage.getItem(key);
          if (value) {
            utms[key] = value;
          }
        });
        return utms;
      }
      
      // Executar captura imediatamente
      const capturedUTMs = captureAndProcessUTMs();
      
      // Configurar preserva√ß√£o de redirecionamentos
      setupRedirectPreservation();
      
      // Expor fun√ß√µes globalmente
      window.UTMTracking = {
        capture: captureAndProcessUTMs,
        get: getProcessedUTMs,
        preserve: preserveUTMsInRedirect,
        log: log
      };
      
      // Executar novamente quando DOM estiver pronto (fallback)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          log('Re-executando captura ap√≥s DOMContentLoaded');
          captureAndProcessUTMs();
        });
      }
      
      log('Script UTM Tracking carregado e executado');
    })();
  </script>

  <!-- üéØ INTERCEPTADOR DO PIXEL DA UTMIFY - DEVE VIR ANTES DO PIXEL -->
  <!-- Este script intercepta e registra todas as requisi√ß√µes do Pixel da UTMify -->
  <script src="utmify-pixel-interceptor.js"></script>

  <!-- Facebook Pixel removido da Rota 1 (Telegram) conforme solicitado -->

  <link rel="stylesheet" href="style.css" />
  <script src="config.js"></script>
  <!-- üö® REMOVIDO: utm-capture.js - substitu√≠do pelo script inline acima -->
  <script src="fbclid-handler.js"></script>
  <script src="event-id.js"></script>
  <script src="utmify-back-redirect.js"></script>
  <script src="event-tracking-initiate.js"></script>
  <!-- Kwai Click ID tracker: captura e persiste o click_id -->
  <script src="kwai-click-tracker.js"></script>

  <!-- üéØ SISTEMA COMPLETO DE RASTREAMENTO -->
  <!-- S√≥ ativa na Rota 2 (Privacy) -->
  <script src="tracking.js"></script>
  
  <script
    src="https://cdn.utmify.com.br/scripts/utms/latest.js"
    data-utmify-prevent-xcod-sck
    data-utmify-prevent-subids
    async
    defer
  ></script>
</head>
<body>
  <!-- V√≠deo de fundo -->
  <video id="background-video" src="assets/video.mp4" autoplay muted loop playsinline preload="metadata"></video>
  
  <!-- Overlay com conte√∫do -->
  <div class="overlay">
    <!-- T√≠tulo da oferta -->
    <h2 class="offer-title">Hadrielle Maria</h2>
    
    <!-- Imagem circular com borda neon -->
    <div class="profile-image-container">
      <img src="assets/imagem.jpg" alt="Modelo" class="profile-image">
    </div>
    
    <!-- Status ONLINE AGORA -->
    <div class="row-status">
      <span class="dot">‚óè</span>
      <span>ONLINE AGORA</span>
      <span class="sep">‚Ä¢</span>
      <span class="loc">
        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
          <path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 9.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5z"/>
        </svg>
        <span id="city"></span>
      </span>
    </div>
    
    <!-- Nova copy principal -->
    <h1 class="main-headline">A melhor bunda que voc√™ vai ver hoje, com os peitos perfeitos üçë</h1>
    
    <!-- Bot√µes -->
    <!-- Bot√£o Privacy (acima) -->
    <a id="cta-privacy" class="btn btn-privacy" href="https://ohvips.xyz/privacy">
      <div class="btn-content">
        <img src="assets/icon-3.png" alt="Privacy" class="btn-icon">
        <span class="btn-text">Privacy</span>
      </div>
    </a>
    
    <!-- Bot√£o WhatsApp (meio) -->
    <a id="cta-whatsapp" class="btn btn-whatsapp" href="https://wa.me/5513981518711?text=Oi%2C%20quero%20comprar%20seu%20conte%C3%BAdo.">
      <div class="btn-content">
        <img src="assets/icon-1.png" alt="WhatsApp" class="btn-icon">
        <span class="btn-text">WhatsApp</span>
      </div>
    </a>
    
    <!-- Bot√£o Telegram (abaixo) -->
    <a id="cta" class="btn btn-telegram" href="#">
      <div class="btn-content">
        <img src="assets/icon-2.png" alt="Telegram" class="btn-icon">
        <span class="btn-text">Telegram</span>
      </div>
    </a>
  </div>

  <script>
  // --- KWAI EVENT API HELPERS ---
  async function sendKwaiEvent(eventName, properties = {}) {
    const clickId = window.KwaiClickTracker?.getClickId();
    if (!clickId) {
      console.warn(`[KWAI] click_id ausente - evento ${eventName} n√£o enviado`);
      return;
    }
    try {
      const resp = await fetch('/api/kwai-event', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ eventName, clickid: clickId, properties })
      });
      const data = await resp.json().catch(() => ({}));
      if (resp.ok && data.success) {
        console.log(`‚úÖ [KWAI] ${eventName} enviado`, data);
      } else {
        console.error(`‚ùå [KWAI] Falha ao enviar ${eventName}`, data);
      }
    } catch (e) {
      console.error(`‚ùå [KWAI] Erro de rede em ${eventName}`, e);
    }
  }

  const cta = document.getElementById("cta");
  const ctaPrivacy = document.getElementById("cta-privacy");
  const ctaWhatsapp = document.getElementById("cta-whatsapp");
  const baseUrl = "https://t.me/vipshadrie_bot";
  const privacyCheckoutUrl = "https://ohvips.xyz/privacy"; // URL base do checkout Privacy
  const whatsappUrl = "https://wa.me/5513981518711?text=Oi%2C%20quero%20comprar%20seu%20conte%C3%BAdo.%20Me%20explica%20como%20funciona";
  const trackData = {};

  let welcomeEventFired = false;

  function trackWelcomeEvent() {
    if (!welcomeEventFired) {
      welcomeEventFired = true;
      fetch('/api/track-welcome', { method: 'POST' })
        .then(() => console.log('‚úÖ Welcome event fired from index.html'))
        .catch(err => console.error('Erro ao rastrear evento welcome:', err));
    }
  }

  // Fun√ß√£o removida - Pixel n√£o mais usado na Rota 1

  function getCookie(name) {
    const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
    return match ? decodeURIComponent(match[1]) : null;
  }

  function getPixelValue(lsKey, cookieName) {
    const defaultValue = lsKey === 'fbp' ? 'nofbp' : 'nofbc';
    return new Promise(resolve => {
      try {
        const stored = localStorage.getItem(lsKey);
        if (stored) return resolve(stored);

        const cookieVal = getCookie(cookieName);
        if (cookieVal) {
          localStorage.setItem(lsKey, cookieVal);
          return resolve(cookieVal);
        }
      } catch (e) {
        console.error('Erro ao acessar storage/cookie', e);
      }

      resolve(defaultValue);
    });
  }

  async function gatherTracking() {
    const fresh = {};

    const [fbp, fbc] = await Promise.all([
      getPixelValue('fbp', '_fbp'),
      getPixelValue('fbc', '_fbc')
    ]);

    let ip = localStorage.getItem('client_ip_address');
    if (!ip) {
      try {
        const fetchIp = fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => d.ip);
        ip = await Promise.race([
          fetchIp,
          new Promise(res => setTimeout(() => res(null), 2000))
        ]);
        if (ip) localStorage.setItem('client_ip_address', ip);
      } catch (e) {}
    }

    let ua = localStorage.getItem('user_agent_criacao');
    if (!ua) {
      try {
        ua = navigator.userAgent;
        localStorage.setItem('user_agent_criacao', ua);
      } catch (e) {}
    }

    const urlParams = new URLSearchParams(window.location.search);
    ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'].forEach(key => {
      const value = urlParams.get(key) || localStorage.getItem(key);
      if (value) {
        fresh[key] = value;
        localStorage.setItem(key, value);
      }
    });

    if (fbp) fresh.fbp = fbp;
    if (fbc) fresh.fbc = fbc;
    if (ip) fresh.ip = ip;
    if (ua) fresh.user_agent = ua;

    // Capturar click_id do Kwai e persistir
    const kwaiClick = window.KwaiClickTracker?.getClickId();
    if (kwaiClick) {
      fresh.kwai_click_id = kwaiClick;
      localStorage.setItem('kwai_click_id', kwaiClick);
    }

    Object.assign(trackData, fresh);
    console.log('[DEBUG] trackData:', trackData);
    return fresh;
  }


  async function gerarPayload() {
    try {
      await gatherTracking();
      const { fbp, fbc, ip, user_agent, utm_source, utm_medium, utm_campaign, utm_term, utm_content, kwai_click_id } = trackData;
      const resp = await fetch('/api/gerar-payload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          fbp,
          fbc,
          ip,
          user_agent,
          utm_source,
          utm_medium,
          utm_campaign,
          utm_term,
          utm_content,
          kwai_click_id
        })
      });

      const data = await resp.json().catch(() => ({}));
      if (resp.ok && data.payload_id) {
        const clickParam = kwai_click_id ? `&click_id=${encodeURIComponent(kwai_click_id)}` : '';
        cta.href = `${baseUrl}?start=${data.payload_id}${clickParam}`;
        trackWelcomeEvent();
      } else {
        cta.href = kwai_click_id ? `${baseUrl}?click_id=${encodeURIComponent(kwai_click_id)}` : baseUrl;
        trackWelcomeEvent();
      }
    } catch (e) {
      console.error('Erro ao gerar payload', e);
      cta.href = baseUrl;
      trackWelcomeEvent();
    }
  }

  // Fun√ß√£o para construir URL do Privacy com par√¢metros
  async function buildPrivacyUrl() {
    try {
      await gatherTracking();
      const { fbp, fbc, utm_source, utm_medium, utm_campaign, utm_term, utm_content, kwai_click_id } = trackData;
      
      const url = new URL(privacyCheckoutUrl);
      
      // Adicionar par√¢metros de tracking
      if (fbp && fbp !== 'nofbp') url.searchParams.set('fbp', fbp);
      if (fbc && fbc !== 'nofbc') url.searchParams.set('fbc', fbc);
      if (utm_source) url.searchParams.set('utm_source', utm_source);
      if (utm_medium) url.searchParams.set('utm_medium', utm_medium);
      if (utm_campaign) url.searchParams.set('utm_campaign', utm_campaign);
      if (utm_term) url.searchParams.set('utm_term', utm_term);
      if (utm_content) url.searchParams.set('utm_content', utm_content);
      if (kwai_click_id) url.searchParams.set('click_id', kwai_click_id);
      
      return url.toString();
    } catch (e) {
      console.error('Erro ao construir URL do Privacy:', e);
      return privacyCheckoutUrl;
    }
  }

  window.addEventListener('load', () => {
    // Disparar EVENT_CONTENT_VIEW assim que a p√°gina estiver pronta
    sendKwaiEvent('EVENT_CONTENT_VIEW', {
      content_name: document.title || 'Presell',
      content_type: 'landing_page'
    });

    cta.classList.add('disabled');
    cta.href = '#';

    ctaPrivacy.classList.add('disabled');
    ctaPrivacy.href = '#';

    ctaWhatsapp.classList.add('disabled');
    ctaWhatsapp.href = '#';

    setTimeout(async () => {
      await gerarPayload();
      cta.classList.remove('disabled');

      // Configurar bot√£o Privacy
      const privacyUrl = await buildPrivacyUrl();
      ctaPrivacy.href = privacyUrl;
      ctaPrivacy.classList.remove('disabled');

      // Configurar bot√£o WhatsApp
      ctaWhatsapp.href = whatsappUrl;
      ctaWhatsapp.classList.remove('disabled');
    }, 500);
  });

  cta.addEventListener("click", function () {
    try {
      // Rastrear clique do CTA no backend
      fetch('/api/track-cta-click', { method: 'POST' })
        .catch(err => console.error('Erro ao rastrear clique do CTA:', err));

      // üö´ TEMPORARIAMENTE DESABILITADO - EVENTOS DUPLICADOS
      console.log('‚ö†Ô∏è EVENTO KWAI AddToCart DESABILITADO - Evitando duplica√ß√£o');
      // sendKwaiEvent('EVENT_ADD_TO_CART', {
      //   content_name: 'Bot√£o Telegram',
      //   content_type: 'cta'
      // });
      
      console.log('‚úÖ Redirecionando para Telegram');
      
    } catch (e) {
      console.error('‚ùå Erro no fluxo de eventos:', e);
    }
  });

  // Evento do bot√£o Privacy - redirecionamento com tracking
  ctaPrivacy.addEventListener("click", async function (e) {
    e.preventDefault();
    try {
      console.log('üéØ Bot√£o Privacy clicado - construindo URL com tracking');

      // üö´ TEMPORARIAMENTE DESABILITADO - EVENTOS DUPLICADOS
      console.log('‚ö†Ô∏è EVENTO KWAI AddToCart DESABILITADO - Evitando duplica√ß√£o');
      // sendKwaiEvent('EVENT_ADD_TO_CART', {
      //   content_name: 'Bot√£o Privacy',
      //   content_type: 'cta'
      // });
      
      // Construir URL com par√¢metros de tracking
      const privacyUrl = await buildPrivacyUrl();
      
      console.log('‚úÖ Redirecionando para Privacy checkout:', privacyUrl);
      
      // Redirecionar para a URL constru√≠da
      window.location.href = privacyUrl;
      
    } catch (e) {
      console.error('‚ùå Erro no clique do Privacy:', e);
      // Fallback para URL simples
      window.location.href = privacyCheckoutUrl;
    }
  });

  // Evento do bot√£o WhatsApp - redirecionamento direto
  ctaWhatsapp.addEventListener("click", function (e) {
    try {
      console.log('üéØ Bot√£o WhatsApp clicado - redirecionando para WhatsApp');

      // Rastrear clique do CTA no backend
      fetch('/api/track-cta-click', { method: 'POST' })
        .catch(err => console.error('Erro ao rastrear clique do CTA WhatsApp:', err));

      // üö´ TEMPORARIAMENTE DESABILITADO - EVENTOS DUPLICADOS
      console.log('‚ö†Ô∏è EVENTO KWAI AddToCart DESABILITADO - Evitando duplica√ß√£o');
      // sendKwaiEvent('EVENT_ADD_TO_CART', {
      //   content_name: 'Bot√£o WhatsApp',
      //   content_type: 'cta'
      // });
      
      console.log('‚úÖ Redirecionando para WhatsApp');
      
    } catch (e) {
      console.error('‚ùå Erro no clique do WhatsApp:', e);
    }
  });

  // Otimiza√ß√µes de performance para o v√≠deo de fundo
  const backgroundVideo = document.getElementById('background-video');
  
  // Configurar qualidade reduzida para melhor performance
  backgroundVideo.addEventListener('loadedmetadata', function() {
    // Reduzir qualidade do v√≠deo
    this.style.imageRendering = 'pixelated';
    this.style.imageRendering = '-webkit-optimize-contrast';
    
    // Pausar v√≠deo se n√£o estiver vis√≠vel (economia de bateria)
    if (document.hidden) {
      this.pause();
    }
  });
  
  // Pausar v√≠deo quando a aba n√£o estiver ativa
  document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      backgroundVideo.pause();
    } else {
      backgroundVideo.play();
    }
  });
  
  // Reduzir taxa de quadros em dispositivos m√≥veis
  if (window.innerWidth <= 768) {
    backgroundVideo.style.filter = 'blur(6px)';
    backgroundVideo.style.opacity = '0.3';
  }

  // Background removido - apenas v√≠deo de fundo

  // Geolocaliza√ß√£o din√¢mica
  const cityEl = document.getElementById("city");
  async function detectCity() {
    try {
      const response = await fetch("https://pro.ip-api.com/json/?key=R1a8D9VJfrqTqpY&fields=status,country,countryCode,region,city");
      const data = await response.json();
      
      if (data.status === "success" && data.city) {
        cityEl.textContent = data.city;
        console.log('Cidade detectada:', data.city);
      } else {
        cityEl.textContent = "Perto de voc√™";
        console.log('Fallback: Cidade n√£o detectada ou status != success');
      }
    } catch (error) {
      cityEl.textContent = "Perto de voc√™";
      console.log('Fallback: Erro na API de geolocaliza√ß√£o', error);
    }
  }
  detectCity();
  </script>

  <!-- Footer com informa√ß√µes legais -->
  <div style="position: fixed; bottom: 10px; left: 0; right: 0; text-align: center; font-size: 10px; z-index: 1000;">
    <div style="color: rgba(255,255,255,0.6); text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">
      Todos os direitos reservados a Hadrielle Maria. Qualquer vazamento de imagem √© crime ‚Äî C√≥digo Penal (Decreto-Lei 2.848/1940).
    </div>
  </div>
</body></html>
