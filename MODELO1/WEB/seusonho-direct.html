<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta name="facebook-domain-verification" content="hieiucxte7adq8gzeeeqvrnzlpulrn" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title id="dynamic-title">Carregando...</title>
  <meta name="robots" content="noindex, nofollow" />

  <!-- üöÄ OTIMIZA√á√ïES DE PERFORMANCE - PRECARREGAMENTO DE DOM√çNIOS -->
  <link rel="preconnect" href="https://t.me" crossorigin>
  <link rel="dns-prefetch" href="https://t.me">
  <link rel="preconnect" href="https://cdn.utmify.com.br" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.utmify.com.br">
  <link rel="preconnect" href="https://connect.facebook.net" crossorigin>
  <link rel="dns-prefetch" href="https://connect.facebook.net">

  <!-- üö® SCRIPT DE CAPTURA DE UTMs - DEVE SEMPRE PERMANECER NO TOPO DO HEAD -->
  <!-- Executa imediatamente para capturar UTMs antes de qualquer script async/defer -->
  <script>
    (function() {
      'use strict';
      
      // Configura√ß√£o
      const UTM_KEYS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term'];
      const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname.includes('dev');
      
      // Logging centralizado
      function log(message, data = null) {
        if (DEBUG_MODE) {
          console.log(`[UTM-TRACKING] ${message}`, data || '');
        }
      }
      
      // Fun√ß√£o para decodificar valor UTM
      function decodeUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        try {
          const decoded = decodeURIComponent(value);
          log(`Decodificado: "${value}" ‚Üí "${decoded}"`);
          return decoded;
        } catch (error) {
          log(`Erro ao decodificar "${value}":`, error);
          return value; // Retorna original se falhar
        }
      }
      
      // Fun√ß√£o para validar e separar formato nome|id
      function parseUTMValue(value) {
        if (!value || typeof value !== 'string') return null;
        
        const parts = value.split('|');
        if (parts.length === 2) {
          const [name, id] = parts;
          const isValid = name && id && /^\d+$/.test(id.trim());
          
          log(`Parse UTM: "${value}" ‚Üí nome: "${name}", id: "${id}", v√°lido: ${isValid}`);
          
          return {
            original: value,
            name: name.trim(),
            id: id.trim(),
            isValid: isValid
          };
        } else {
          log(`UTM sem formato nome|id: "${value}"`);
          return {
            original: value,
            name: value,
            id: null,
            isValid: false
          };
        }
      }
      
      // Fun√ß√£o para capturar UTMs da URL atual
      function captureUTMsFromURL() {
        const url = window.location.href;
        const searchParams = window.location.search;
        
        log('URL Original:', url);
        log('Query Params Bruto:', searchParams);
        
        if (!searchParams) {
          log('Nenhum par√¢metro UTM encontrado na URL');
          return {};
        }
        
        const params = new URLSearchParams(searchParams);
        const capturedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const rawValue = params.get(key);
          if (rawValue !== null) {
            const decodedValue = decodeUTMValue(rawValue);
            const parsed = parseUTMValue(decodedValue);
            
            capturedUTMs[key] = {
              raw: rawValue,
              decoded: decodedValue,
              parsed: parsed
            };
            
            log(`UTM ${key}:`, capturedUTMs[key]);
          }
        });
        
        return capturedUTMs;
      }
      
      // Fun√ß√£o para obter UTMs salvos do localStorage
      function getSavedUTMs() {
        const savedUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const saved = localStorage.getItem(key);
          if (saved) {
            const parsed = parseUTMValue(saved);
            savedUTMs[key] = {
              saved: saved,
              parsed: parsed
            };
            log(`UTM salvo ${key}:`, savedUTMs[key]);
          }
        });
        
        return savedUTMs;
      }
      
      // Fun√ß√£o para salvar UTMs no localStorage
      function saveUTMs(utms) {
        Object.keys(utms).forEach(key => {
          const utmData = utms[key];
          if (utmData && utmData.decoded) {
            localStorage.setItem(key, utmData.decoded);
            log(`Salvo no localStorage: ${key} = "${utmData.decoded}"`);
          }
        });
      }
      
      // Fun√ß√£o principal de captura
      function captureAndProcessUTMs() {
        log('=== INICIANDO CAPTURA DE UTMs ===');
        
        // 1. Capturar UTMs da URL atual
        const urlUTMs = captureUTMsFromURL();
        
        // 2. Obter UTMs salvos do localStorage
        const savedUTMs = getSavedUTMs();
        
        // 3. Processar e salvar UTMs v√°lidos
        const validUTMs = {};
        
        UTM_KEYS.forEach(key => {
          const urlUTM = urlUTMs[key];
          const savedUTM = savedUTMs[key];
          
          if (urlUTM && urlUTM.parsed && urlUTM.parsed.isValid) {
            // Priorizar UTMs da URL se v√°lidos
            validUTMs[key] = urlUTM.decoded;
            log(`Usando UTM da URL: ${key} = "${urlUTM.decoded}"`);
          } else if (savedUTM && savedUTM.parsed && savedUTM.parsed.isValid) {
            // Fallback para UTMs salvos se v√°lidos
            validUTMs[key] = savedUTM.saved;
            log(`Usando UTM salvo: ${key} = "${savedUTM.saved}"`);
          } else if (urlUTM && urlUTM.decoded) {
            // Salvar mesmo se n√£o tiver formato nome|id
            validUTMs[key] = urlUTM.decoded;
            log(`Salvando UTM sem formato nome|id: ${key} = "${urlUTM.decoded}"`);
          }
        });
        
        // 4. Salvar no localStorage
        saveUTMs(urlUTMs);
        
        log('=== UTMs CAPTURADOS ===', validUTMs);
        return validUTMs;
      }
      
      // Fun√ß√£o para obter UTMs processados
      function getProcessedUTMs() {
        const utms = {};
        UTM_KEYS.forEach(key => {
          const value = localStorage.getItem(key);
          if (value) {
            utms[key] = value;
          }
        });
        return utms;
      }
      
      // Executar captura imediatamente
      const capturedUTMs = captureAndProcessUTMs();
      
      // Expor fun√ß√µes globalmente
      window.UTMTracking = {
        capture: captureAndProcessUTMs,
        get: getProcessedUTMs,
        log: log
      };
      
      // Executar novamente quando DOM estiver pronto (fallback)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          log('Re-executando captura ap√≥s DOMContentLoaded');
          captureAndProcessUTMs();
        });
      }
      
      log('Script UTM Tracking carregado e executado');
    })();
  </script>

  <!-- üéØ INTERCEPTADOR DO PIXEL DA UTMIFY - DEVE VIR ANTES DO PIXEL -->
  <!-- Este script intercepta e registra todas as requisi√ß√µes do Pixel da UTMify -->
  <script src="utmify-pixel-interceptor.js"></script>

  <!-- SOLU√á√ÉO PARA event-id.js AUSENTE -->
  <script>
    // SOLU√á√ÉO PARA event-id.js AUSENTE
    function generateEventID(eventName) {
      return `${eventName}.${Date.now()}.${Math.random().toString(36).substr(2, 9)}`;
    }

    function addTestEventCode(data) {
      if (window.fbConfig && window.fbConfig.FB_TEST_EVENT_CODE) {
        data.test_event_code = window.fbConfig.FB_TEST_EVENT_CODE;
      }
      return data;
    }
  </script>

    <!-- Facebook Pixel -->
  <script>
    window.fbConfig = { FB_PIXEL_ID: '', FB_TEST_EVENT_CODE: '', loaded: false };
    async function loadFacebookConfig() {
      try {
        const r = await fetch('/api/config');
        const cfg = await r.json();
        window.fbConfig.FB_PIXEL_ID = cfg.FB_PIXEL_ID;
        window.fbConfig.FB_TEST_EVENT_CODE = cfg.FB_TEST_EVENT_CODE;
        window.fbConfig.loaded = true;
      } catch (e) {
        console.error('Erro ao carregar config do Facebook', e);
      }
    }
    loadFacebookConfig();
  </script>
  <script>
    !function(f,b,e,v,n,t,s){
      if(f.fbq)return;n=f.fbq=function(){
        n.callMethod ? n.callMethod.apply(n,arguments) : n.queue.push(arguments)};
      if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
      n.queue=[];t=b.createElement(e);t.async=!0;
      t.src=v;s=b.getElementsByTagName(e)[0];
      s.parentNode.insertBefore(t,s)
    }(window, document, 'script', 'https://connect.facebook.net/en_US/fbevents.js');

    // Aguardar carregamento das configura√ß√µes antes de inicializar
    function initializeFacebookPixel() {
      if (window.fbConfig && window.fbConfig.loaded && window.fbConfig.FB_PIXEL_ID && typeof fbq === 'function') {
        fbq('init', window.fbConfig.FB_PIXEL_ID);
        
        const pageViewId = generateEventID('PageView');
        const pageViewData = addTestEventCode({ eventID: pageViewId });
        fbq('track', 'PageView', pageViewData);
        
        const viewInitId = generateEventID('ViewContent');
        const viewContentData = addTestEventCode({
          value: parseFloat((Math.random() * (19.90 - 9.90) + 9.90).toFixed(2)),
          currency: 'BRL',
          eventID: viewInitId
        });
        fbq('track', 'ViewContent', viewContentData);
        
        console.debug('üîß Facebook Pixel inicializado com:', window.fbConfig.FB_PIXEL_ID);
      } else {
        // Retry ap√≥s 100ms se configura√ß√µes ainda n√£o carregaram
        setTimeout(initializeFacebookPixel, 100);
      }
    }
    
    // Inicializar quando DOM estiver pronto
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeFacebookPixel);
    } else {
      initializeFacebookPixel();
    }
  </script>

  <script src="config.js"></script>
  <script src="fbclid-handler.js"></script>
  <script src="event-id.js"></script>
  <script src="utmify-back-redirect.js"></script>
  <script
    src="https://cdn.utmify.com.br/scripts/utms/latest.js"
    data-utmify-prevent-xcod-sck
    data-utmify-prevent-subids
    async
    defer
  ></script>
</head>
<body>
  <script>
    // Configura√ß√£o da p√°gina (pode ser mantida do seu c√≥digo original)
    window.config = {
      title: 'Seusonho - Redirecionamento Autom√°tico',
      headline: 'Acesso Direto VIP',
      redirectLink: 'https://t.me/vipshadrie_bot?start='
    };
    document.title = window.config.title;

    /**
     * Fun√ß√£o principal e otimizada para executar o redirecionamento r√°pido.
     * Esta fun√ß√£o ser√° chamada assim que o DOM estiver pronto, sem esperar por imagens.
     */
    async function executarRedirecionamentoOtimizado() {
      console.log('üöÄ Processo de redirecionamento otimizado iniciado!');

      // 1. COLETAR DADOS ESSENCIAIS IMEDIATAMENTE
      const utms = window.UTMTracking.get();
      const fbp = getCookie('_fbp');
      const fbc = getCookie('_fbc');
      const user_agent = navigator.userAgent || '';
      const trackingData = {
        ...utms,
        fbp,
        fbc,
        user_agent,
        page: '/seusonho',
        timestamp: new Date().toISOString()
      };
      console.log('üìä Dados de rastreamento coletados:', trackingData);

      // 2. DISPARAR PIXEL DO NAVEGADOR (FIRE-AND-FORGET)
      if (typeof fbq === 'function') {
        const viewContentData = addTestEventCode({
          value: parseFloat((Math.random() * (19.90 - 9.90) + 9.90).toFixed(2)),
          currency: 'BRL',
          content_name: window.config.headline,
          content_category: 'Bot Telegram',
          eventID: generateEventID('ViewContent')
        });
        fbq('track', 'ViewContent', viewContentData);
        console.log('üéØ Pixel ViewContent do navegador disparado.');
      }

      // 3. EXECUTAR TAREFAS DE SERVIDOR EM PARALELO
      const baseUrl = window.config.redirectLink;
      let finalUrl = baseUrl;

      try {
        console.log('üì¶ Solicitando payload e iniciando tarefas de fundo...');
        const payloadPromise = fetch('/api/gerar-payload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(trackingData)
        });

        fetch('/api/track-seusonho-access', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(trackingData)
        })
        .then(() => console.log('‚úÖ Acesso registrado no Google Sheets (background).'))
        .catch(err => console.error('‚ùå Erro ao registrar no Sheets (background):', err));

        const capiData = {
          event_id: generateEventID('ViewContent'),
          url: window.location.href,
          fbp: trackingData.fbp,
          fbc: trackingData.fbc,
          content_name: 'Seusonho - Acesso Direto VIP',
          content_category: 'Bot Telegram',
          value: 19.90,
          currency: 'BRL'
        };
        fetch('/api/capi/viewcontent', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(capiData)
        })
        .then(() => console.log('‚úÖ ViewContent CAPI enviado (background).'))
        .catch(err => console.error('‚ùå Erro ao enviar CAPI (background):', err));

        const payloadResponse = await payloadPromise;
        if (payloadResponse.ok) {
          const payloadData = await payloadResponse.json();
          if (payloadData.payload_id) {
            finalUrl = `${baseUrl}${payloadData.payload_id}`;
            console.log('‚úÖ Payload recebido:', payloadData.payload_id);
          }
        }
      } catch (error) {
        console.error('üî• Erro cr√≠tico no processo de gera√ß√£o de payload:', error);
      } finally {
        console.log('‚è≥ Adicionando delay de 1 segundo para garantir o rastreamento...');
        await new Promise(resolve => setTimeout(resolve, 1000)); // Pausa de 1 segundo

        console.log(`üöÄ Redirecionando para: ${finalUrl}`);
        window.location.href = finalUrl;
      }
    }

    function getCookie(name) {
      const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : null;
    }

    document.addEventListener('DOMContentLoaded', executarRedirecionamentoOtimizado);
  </script>

</body>
</html>
