/**
 * üéØ INTERCEPTADOR DO PIXEL DA UTMIFY
 * 
 * Este script intercepta e registra todas as requisi√ß√µes feitas pelo Pixel da UTMify
 * para facilitar o debugging e valida√ß√£o do rastreamento.
 * 
 * DEVE SER CARREGADO ANTES do Pixel da UTMify para capturar a primeira requisi√ß√£o.
 */

(function() {
  'use strict';
  
  // Configura√ß√£o
  const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname.includes('dev');
  const UTMIFY_DOMAINS = ['cdn.utmify.com.br', 'api.utmify.com.br', 'utmify.com.br'];
  const UTM_KEYS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term'];
  
  // Contador de requisi√ß√µes
  let requestCounter = 0;
  const pageLoadTime = performance.now();
  
  // Logging centralizado
  function log(message, data = null, level = 'info') {
    if (!DEBUG_MODE && level === 'debug') return;
    
    const timestamp = new Date().toISOString();
    const timeSinceLoad = (performance.now() - pageLoadTime).toFixed(2);
    const prefix = `[UTMIFY-INTERCEPTOR] [${timestamp}] [+${timeSinceLoad}ms]`;
    
    switch(level) {
      case 'error':
        console.error(prefix, message, data || '');
        break;
      case 'warn':
        console.warn(prefix, message, data || '');
        break;
      case 'debug':
        console.debug(prefix, message, data || '');
        break;
      default:
        console.log(prefix, message, data || '');
    }
  }
  
  // Fun√ß√£o para verificar se √© uma requisi√ß√£o da UTMify
  function isUTMifyRequest(url) {
    try {
      const urlObj = new URL(url);
      return UTMIFY_DOMAINS.some(domain => urlObj.hostname.includes(domain));
    } catch (e) {
      return false;
    }
  }
  
  // Fun√ß√£o para analisar UTMs no formato nome|id
  function analyzeUTMs(payload) {
    const utmAnalysis = {};
    
    UTM_KEYS.forEach(key => {
      const value = payload[key];
      if (value) {
        const parts = value.split('|');
        if (parts.length === 2) {
          const [name, id] = parts;
          const isValid = name && id && /^\d+$/.test(id.trim());
          
          utmAnalysis[key] = {
            original: value,
            name: name.trim(),
            id: id.trim(),
            isValid: isValid,
            format: 'nome|id'
          };
        } else {
          utmAnalysis[key] = {
            original: value,
            name: value,
            id: null,
            isValid: false,
            format: 'simples'
          };
        }
      }
    });
    
    return utmAnalysis;
  }
  
  // Fun√ß√£o para formatar payload para debug
  function formatPayload(payload) {
    try {
      const utmAnalysis = analyzeUTMs(payload);
      const hasValidUTMs = Object.values(utmAnalysis).some(utm => utm.isValid);
      
      return {
        summary: {
          totalUTMs: Object.keys(utmAnalysis).length,
          validUTMs: Object.values(utmAnalysis).filter(utm => utm.isValid).length,
          hasValidFormat: hasValidUTMs
        },
        utms: utmAnalysis,
        fullPayload: payload
      };
    } catch (e) {
      log('Erro ao formatar payload:', e, 'error');
      return { error: e.message, rawPayload: payload };
    }
  }
  
  // Interceptar XMLHttpRequest
  function interceptXHR() {
    const originalOpen = XMLHttpRequest.prototype.open;
    const originalSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function(method, url, ...args) {
      this._utmifyInterceptor = {
        method: method,
        url: url,
        timestamp: performance.now()
      };
      return originalOpen.apply(this, [method, url, ...args]);
    };
    
    XMLHttpRequest.prototype.send = function(data) {
      if (this._utmifyInterceptor && isUTMifyRequest(this._utmifyInterceptor.url)) {
        requestCounter++;
        const requestId = `XHR-${requestCounter}`;
        
        log(`üîç Interceptando ${requestId}:`, {
          method: this._utmifyInterceptor.method,
          url: this._utmifyInterceptor.url,
          data: data
        });
        
        // Interceptar resposta
        this.addEventListener('load', function() {
          try {
            const responseData = this.responseText;
            log(`‚úÖ ${requestId} - Resposta recebida:`, {
              status: this.status,
              statusText: this.statusText,
              responseLength: responseData.length,
              responsePreview: responseData.substring(0, 200)
            });
          } catch (e) {
            log(`‚ùå ${requestId} - Erro ao processar resposta:`, e, 'error');
          }
        });
        
        this.addEventListener('error', function() {
          log(`‚ùå ${requestId} - Erro na requisi√ß√£o:`, {
            status: this.status,
            statusText: this.statusText
          }, 'error');
        });
      }
      
      return originalSend.apply(this, [data]);
    };
  }
  
  // Interceptar Fetch
  function interceptFetch() {
    const originalFetch = window.fetch;
    
    window.fetch = function(url, options = {}) {
      if (isUTMifyRequest(url)) {
        requestCounter++;
        const requestId = `FETCH-${requestCounter}`;
        
        const requestData = {
          url: url,
          method: options.method || 'GET',
          headers: options.headers,
          body: options.body
        };
        
        log(`üîç Interceptando ${requestId}:`, requestData);
        
        // Tentar parsear body se for JSON
        if (options.body && typeof options.body === 'string') {
          try {
            const parsedBody = JSON.parse(options.body);
            const formattedPayload = formatPayload(parsedBody);
            
            log(`üìä ${requestId} - An√°lise do Payload:`, formattedPayload);
            
            // Verificar se UTMs est√£o no formato correto
            if (formattedPayload.summary) {
              if (formattedPayload.summary.hasValidFormat) {
                log(`‚úÖ ${requestId} - UTMs no formato nome|id v√°lido`);
              } else {
                log(`‚ö†Ô∏è ${requestId} - UTMs n√£o est√£o no formato nome|id esperado`, 'warn');
              }
            }
          } catch (e) {
            log(`‚ùå ${requestId} - Erro ao parsear body:`, e, 'error');
          }
        }
        
        return originalFetch.apply(this, [url, options]).then(response => {
          log(`‚úÖ ${requestId} - Resposta recebida:`, {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok
          });
          return response;
        }).catch(error => {
          log(`‚ùå ${requestId} - Erro na requisi√ß√£o:`, error, 'error');
          throw error;
        });
      }
      
      return originalFetch.apply(this, [url, options]);
    };
  }
  
  // Interceptar Beacon API (usado por alguns pixels)
  function interceptBeacon() {
    const originalSendBeacon = navigator.sendBeacon;
    
    navigator.sendBeacon = function(url, data) {
      if (isUTMifyRequest(url)) {
        requestCounter++;
        const requestId = `BEACON-${requestCounter}`;
        
        log(`üîç Interceptando ${requestId}:`, {
          url: url,
          dataType: typeof data,
          dataLength: data ? data.length : 0
        });
        
        // Tentar parsear dados se for string
        if (data && typeof data === 'string') {
          try {
            const parsedData = JSON.parse(data);
            const formattedPayload = formatPayload(parsedData);
            log(`üìä ${requestId} - An√°lise do Payload:`, formattedPayload);
          } catch (e) {
            log(`‚ùå ${requestId} - Erro ao parsear dados:`, e, 'error');
          }
        }
      }
      
      return originalSendBeacon.apply(this, [url, data]);
    };
  }
  
  // Fun√ß√£o para monitorar mudan√ßas no DOM (pixels din√¢micos)
  function monitorDOMChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Verificar se √© um script da UTMify
            if (node.tagName === 'SCRIPT' && node.src) {
              if (isUTMifyRequest(node.src)) {
                log('üîç Script da UTMify detectado no DOM:', {
                  src: node.src,
                  async: node.async,
                  defer: node.defer
                });
              }
            }
            
            // Verificar se √© uma imagem de tracking
            if (node.tagName === 'IMG' && node.src) {
              if (isUTMifyRequest(node.src)) {
                log('üîç Imagem de tracking da UTMify detectada:', {
                  src: node.src,
                  alt: node.alt
                });
              }
            }
          }
        });
      });
    });
    
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    
    log('üëÅÔ∏è Monitoramento de mudan√ßas no DOM ativado');
  }
  
  // Fun√ß√£o para gerar relat√≥rio final
  function generateFinalReport() {
    const timeSinceLoad = (performance.now() - pageLoadTime).toFixed(2);
    
    log('üìã RELAT√ìRIO FINAL DO INTERCEPTADOR:', {
      totalRequests: requestCounter,
      timeSincePageLoad: `${timeSinceLoad}ms`,
      utmifyDomains: UTMIFY_DOMAINS,
      debugMode: DEBUG_MODE
    });
  }
  
  // Inicializar interceptadores
  function initialize() {
    log('üöÄ Inicializando interceptador do Pixel da UTMify');
    
    interceptXHR();
    interceptFetch();
    interceptBeacon();
    monitorDOMChanges();
    
    log('‚úÖ Interceptadores configurados');
    
    // Gerar relat√≥rio final quando p√°gina estiver completamente carregada
    window.addEventListener('load', () => {
      setTimeout(generateFinalReport, 2000); // Aguardar 2s para capturar requisi√ß√µes tardias
    });
  }
  
  // Expor fun√ß√µes globalmente para debugging manual
  window.UTMifyInterceptor = {
    isUTMifyRequest,
    analyzeUTMs,
    formatPayload,
    getRequestCount: () => requestCounter,
    getPageLoadTime: () => pageLoadTime,
    generateReport: generateFinalReport
  };
  
  // Inicializar imediatamente
  initialize();
  
})(); 